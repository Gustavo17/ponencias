\section{Componentes}
\subsection{El servidor}
\begin{frame}{El servidor}
  \begin{itemize}
    \item Espera las conexiones de los usuarios.
    \item Hace la autenticación de usuarios.
    \item Comprueba si la consulta esta en la cache.
    \item Si la consulta esta en la cache, devuelve el resultado.
    \item Si la consulta no esta en la cache, la pasa al parser.
  \end{itemize}
\end{frame}

\subsection{La cache}
\begin{frame}{La cache}
  \begin{itemize}
    \item La cache almacena resultados asociados a ''hash'' de consultas.
    \item Cualquier modificación en una tabla relacionada con una consulta, caduca esa consulta.
  \end{itemize}
\end{frame}

\subsection{El parser}
\begin{frame}{El parser}
  \begin{itemize}
    \item Recibe una consulta en SQL, y la convierte en una estructura de árbol.
    \item Pasa la estructura de árbol al optimizador.
  \end{itemize}
\end{frame}

\subsection{El optimizador}
\begin{frame}{El optimizador}
  \begin{itemize}
    \item Se preprocesa el árbol y hace cambios que el parser no hace.
    \item Utiliza la estructura de árbol para hacer optimizaciones.
    \item Mediante datos estadísticos del S.E. y algoritmos de optimización hace diferentes pruebas.
    \item Escoge la prueba que le haya dado un valor mas óptimo.
    \item Algunos ejemplos de algoritmos de optimización:
    \begin{itemize}
      \item Reordenación de Joins
      \item Aplicación de reglas algebraicas.
      \item Evaluación y reducción de expresiones constantes.
      \item \dots
    \end{itemize}
    \item Como resultado del optimizador se obtiene el ''execution plan'' que se aplica a los S.E.
  \end{itemize}
\end{frame}

\subsection{Storage Engines}
\begin{frame}{Introducción}
  \begin{itemize}
    \item Recibe peticiones simples de acceso a datos.
    \item Mediante estas operaciones simples se satisface el ''execution plan''.
    \item Cada S.E. tiene funcionalidades y capacidades diferentes.
  \end{itemize}
\end{frame}

\begin{frame}{MyISAM}
  \begin{itemize}
    \item El tipo por defecto de MySQL.
    \item Muy rápido
    \item Lock por tablas
    \item Índices B-Tree y Full-Text
    \item Tablas comprimidas (solo lectura)
  \end{itemize}
\end{frame}

\begin{frame}{InnoDB}
  \begin{itemize}
    \item Transaccional.
    \item Lock por filas.
    \item Integridad referencial.
    \item Índices B+Tree con clustered index.
  \end{itemize}
\end{frame}

\begin{frame}{Memory (Heap)}
  \begin{itemize}
    \item Tablas en memoria.
    \item Muy rápidas.
    \item Se pierden todos los datos al reiniciar el mysql.
    \item Índices Hash y B-Tree.
  \end{itemize}
\end{frame}

\begin{frame}{CSV}
  \begin{itemize}
    \item Lock por tabla.
    \item Gestiona los datos como ficheros CSV.
    \item Útil para gestionar datos compartidos con otras aplicaciones que solo entienden CSV.
  \end{itemize}
\end{frame}

\begin{frame}{BlackHole}
  \begin{itemize}
    \item Transaccional.
    \item Lock por filas.
    \item Descarta cualquier insert.
    \item El sistema de logs sigue funcionando.
  \end{itemize}
\end{frame}

\begin{frame}{Archive}
  \begin{itemize}
    \item Transaccional.
    \item Lock por filas.
    \item Base de datos orientada a escritura.
    \item Ideal para almacenar logs.
  \end{itemize}
\end{frame}

\begin{frame}{Federated}
  \begin{itemize}
    \item Tabla virtual, traduce las consultas a consultas DBMS.
    \item Por ahora solo permite acceso a otros MySQLs.
  \end{itemize}
\end{frame}

\begin{frame}{Otros}
  \begin{itemize}
    \item Maria
    \item BerkeleyDB
    \item Merge
    \item NDB
    \item Falcon
    \item \dots
  \end{itemize}
\end{frame}
