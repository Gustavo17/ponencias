\section{Esquemas e índices}

\subsection{Introducción}
\begin{frame}{Introducción}
  \begin{itemize}
    \item Nuestros esquemas e índices dependen de la funcionalidad.
    \item Es tan importante el que, como el como.
    \item Todo el diseño debe tener en cuenta los casos de uso.
    \item Es muy diferente un diseño para lectura, escritura o baja latencia.
    \item Todo deriva en un compromiso entre el rendimiento en diferentes situaciones.
  \end{itemize}
\end{frame}

\subsection{Normalización}
\begin{frame}{Normalización}
  \begin{itemize}
    \item Reestructuración de nuestras tablas.
    \item Busca eliminar redundancia.
    \item Se aplican una serie de ''formas normales''.
    \item Normalmente es una buena política.
  \end{itemize}
\end{frame}

\begin{frame}{Des-normalización}
  \begin{itemize}
    \item A veces la normalización es ineficiente.
    \item La redundancia puede producir incrementos de rendimiento significativos.
    \item Bases de datos con mucha lectura y poca escritura.
    \item Bases de datos con necesidades de latencias muy bajas.
  \end{itemize}
\end{frame}

%\subsection{Filas de tamaño fijo}
%\begin{frame}{Filas de tamaño fijo}
%  \begin{itemize}
%    \item Las filas almacenadas en nuestra base de datos tienen un tamaño.
%    \item Este puede ser fijo o variable.
%    \item Las filas de tamaño fijo son mas rápidas.
%    \item Una fila se considera de tamaño fijo, si todos sus campos lo son.
%    \item A veces conviene desaprovechar cierta cantidad de espacio a cambio de rendimiento.
%    \item Dependiendo del tipo de consulta puede resultar mas rápido si ahorramos espacio.
%  \end{itemize}
%\end{frame}

\subsection{Índices}
\begin{frame}{Índices}
  \begin{itemize}
    \item Estructuras auxiliares para búsquedas.
    \item Aceleran las consultas (cuando tienen datos suficientes).
    \item Pueden resolver la consulta entera (si los datos necesarios están contenidos).
    \item Hacen referencia a uno o mas campos.
    \item Los índices de varios campos tienen un orden concreto.
    \item (A,B) != (B,A)
    \item Cada índice incrementa el espacio consumido y decrementa la velocidad de escritura.
  \end{itemize}
\end{frame}

\begin{frame}{Arboles B}
  \begin{itemize}
    \item Este es tipo de índice mas habitual.
    \item El formato interno del árbol depende del S.E.
    \item Este tipo de índice permite las siguientes consultas:
    \begin{itemize}
      \item El valor completo del índice.
      \item Valores en la parte izquierda del índice.
      \item Rangos de valores.
      \item Una parte exacta (a la izquierda), y el resto como un rango.
      \item Consultas de solo el índice.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Tablas hash}
  \begin{itemize}
    \item Para cada columna, se calcula un hash y se asocia al índice.
    \item Solo permite búsquedas exactas.
    \item Las búsquedas son muy rápidas.
    \item Es el tipo por defecto del S.E. Memory.
    \item Este modo no esta disponible en MyISAM o InnoDB, pero se puede ''emular''.
  \end{itemize}
\end{frame}

\begin{frame}{Spatial indexes}
  \begin{itemize}
    \item Índices especiales para GIS.
  \end{itemize}
\end{frame}

\begin{frame}{Full text}
  \begin{itemize}
    \item Índices para búsquedas sobre el contenido.
    \item Solo disponibles en MyISAM (por ahora).
  \end{itemize}
\end{frame}

\begin{frame}{Clustered indexes}
  \begin{itemize}
    \item No es otro tipo de índice, es un concepto.
    \item Consiste en incluir los datos de la fila, dentro del índice de la clave primaria.
    \item Esto permite que la búsqueda de la clave primaria de como resultado la fila, sin necesidad de ningún salto extra.
    \item InnoDB implementa este tipo de árbol B.
  \end{itemize}
\end{frame}

\begin{frame}{Coverage indexes}
  \begin{itemize}
    \item Extraer los datos directamente del índice.
    \item Solo si todos los datos están contenidos en el índice.
    \item Supone un incremento significativo del rendimiento.
  \end{itemize}
\end{frame}
