\documentclass[10pt]{beamer}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}

\mode<presentation>
\usetheme{Madrid}
%\usecolortheme[RGB={111,73,135}]{structure}
\usecolortheme[RGB={128,0,0}]{structure}
%\usecolortheme[RGB={0,96,0}]{structure}
%\usecolortheme[RGB={200,0,200}]{structure}
%\usecolortheme[RGB={0,128,0}]{structure}
%\usecolortheme[RGB={0,0,128}]{structure}
\usefonttheme{serif}
\useinnertheme{rectangles}
\useoutertheme{split}
\setbeamercovered{transparent}


\title{Pruebas unitarias con Python Unit}
\author{Jesús Espino García}
\date{15 de Julio de 2011}
\subject{Pruebas unitarias con Python Unit}

\institute[Python Madrid 2011]{Kaleidos\\Python Madrid 2011}


\setcounter{tocdepth}{2}

\AtBeginSubsection[]
{
  \begin{frame}<beamer>{Indice}
    \tableofcontents[sectionstyle=show/shaded,subsectionstyle=show/shaded/hide]
  \end{frame}
}

\begin{document}

  \frame{\maketitle}


  \section*{Introducción}
  \begin{frame}{¿Que son las pruebas unitarias?}
    \begin{itemize}
      \item Son pruebas individuales de métodos o clases.
      \item Son pruebas automáticas (no por definición, sino por practicidad)
      \item Consiste en muchos casos de prueba
      \begin{itemize}
        \item Cada uno de ellos prueba un aspecto determinado
        \item Para probar un metodo hacen falta varios casos de prueba
      \end{itemize}
    \end{itemize}
  \end{frame}
  
  \begin{frame}{¿Por qué hacer pruebas?}
    \begin{itemize}
      \item Un programa no es aceptable si no comple su especificación.
      \item Un programa no es aceptable si hace lo que no debe hacer.
      \item Nos da sensación de seguridad y tranquilidad.
      \item Evita la inclusion recurrente del mismo error.
    \end{itemize}

    ''Un programador jamás debería entregar un programa sin haberlo probado. Igualmente, quien recibe un programa de otro jamás debería aceptarlo sin haberlo probado. Cualquier funcionalidad de un programa sin una prueba automatizada, simplemente no existe'' (''Extreme Programming Explained'', de Kent Beck)
  \end{frame}
  
  \begin{frame}
    \frametitle{Estrategias de pruebas}
    \begin{itemize}
      \item Ninguna: ''Soy tan bueno que todo lo que hago funciona a la primera, sin ningún tipo de bug''
      \item Al final: Voy desarrollando y al final del proyecto me paso una semana probando, o dejo que pruebe el cliente.
      \item Constante 1: Voy haciendo las pruebas segun desarrollo (Desarrollo -> Prueba).
      \item Constante 2: Voy haciendo las pruebas segun desarrollo (Prueba -> Desarrollo). TDD
      \item Test reactivos: Ante un error, construimos un test que reproduzca el error y lo corregimos.
    \end{itemize}
  \end{frame}
  
  \section*{Modulo unittest de Python}
  \begin{frame}{Introducción}
    \begin{itemize}
      \item Provee de un framework para realizar las pruebas unitarias.
      \item Forma parte de la distribución base de python desde la version 2.1.
      \item Inspirado en JUnit.
    \end{itemize}
  \end{frame}

  \begin{frame}{Conceptos}
    Unittest soporta 4 conceptos importantes
    \begin{itemize}
      \item test fixture: Acciones de preparación previas a los test (por ejemplo, poblado de bases de datos).
      \item test case: Unidad basica de tests, comprueba que el resultado sea el correcto ante unos parametros.
      \item test suite: Una coleccion de ''test cases'' y/o ''test suites''.
      \item test runner: Componente encargado de la ejecucción de los tests y la presentación de los resultados.
    \end{itemize}
  \end{frame}

  \begin{frame}{Estructura de un test case}
    \begin{itemize}
      \item Es una clase que hereda de TestCase.
      \item Tendra una serie de metodos que empiecen por ''test\_'' que seran ejecutados automaticamente.
      \item Los metodos ''test\_'' deben ejecutar el codigo que desean probar y luego ''afirmar un estado''.
      \item Los metodos ''test\_'' no devuelven ningun valor, se consideran validos aquellos que haya terminado su ejecuccion.
    \end{itemize}
  \end{frame}

  \begin{frame}{Afirmando un estado}
    \begin{itemize}
      \item Para afirmar los estados usamos ''aserciones''.
      \item Unittest nos provee de una serie de aserciones, las mas habituales son:
      \begin{itemize}
        \item assertEqual
        \item assertNotEqual
        \item assertTrue
        \item assertFalse
        \item assertIs
        \item assertIsNot
        \item assertIsNone
        \item assertIsNotNone
        \item assertIn
        \item assertNotIn
        \item assertIsInstance
        \item assertNotIsInstance
        \item assertRaise
      \end{itemize}
      \item Pueden ver un listado mas exaustivo de las aserciones en http://docs.python.org/library/unittest.html.
    \end{itemize}
  \end{frame}

  \begin{frame}[containsverbatim]
    \frametitle{Ejemplo de metodo de test}
    \begin{verbatim}
def test_suma(self):
    resultado = 1+1
    assertEqual(rsultado,2)

    resultado = 1+8
    assertEqual(rsultado,9)
    \end{verbatim}
  \end{frame}

  \begin{frame}[containsverbatim]
    \frametitle{Ejemplo fichero de test}
    \begin{verbatim}
import unittest

class TestSuma(unittest.TestCase):
    def test_suma(self):
        resultado = 1+1
        assertEqual(rsultado,2)
    
        resultado = 1+8
        assertEqual(rsultado,9)
        \end{verbatim}
  \end{frame}


  \begin{frame}{Inicialización de los datos}
    \begin{itemize}
      \item Unittest nos permite definir un ''test fixture''.
      \item Para esto definimos los metodos setUp y tearDown.
      \item setUp se ejecuta justo antes de cada metodo test.
      \item tearDown se ejecuta justo despues de cada metodo test.
      \item Nos serviran para inicializar y limpiar los datos de prueba.
      \item Ademas tenemos setUpClass y tearDownClass.
      \item Y setUpModule y tearDownModule.
    \end{itemize}
  \end{frame}

  \begin{frame}{Test Suite}
    \begin{itemize}
      \item Unittest nos permite agrupar tests.
      \item Es util para estructurar los test de diferentes maneras.
      \begin{itemize}
        \item Por funcionalidad.
        \item Por casos de uso.
        \item Por situación en la intefaz.
        \item Por proximidad de los datos.
        \item \dots
      \end{itemize}
    \end{itemize}
  \end{frame}

  \begin{frame}{Test Runner}
    \begin{itemize}
      \item Encargado de ejecutar los tests.
      \item Una clase con un metodo run, que recibe un TestCase o un TestSuite.
      \item Unittest viene solo con el TextTestRunner.
      \item Poemos implementar nuestros propios TestRunners.
    \end{itemize}
  \end{frame}

  \subsection*{Ejemplos}
  \begin{frame}{Ejemplos}
    \begin{itemize}
      \item Test unitario simple.
      \item Ejemplo de setUp, tearDown.
      \item Ejemplo de testSuite.
      \item Ejemplo de test ejecutable.
      \item Ejemplo de test con TestRunner.
    \end{itemize}
  \end{frame}
  
  \subsection*{Para terminar}
  \begin{frame}{Referencias}
    \begin{itemize}
      \item Documentación de unittest: http://docs.python.org/library/unittest.html.
      \item TDD: http://en.wikipedia.org/wiki/Test-driven\_development.
      \item Pruebas Unitarias: http://en.wikipedia.org/wiki/Unit\_testing
      \item Python-ES: python-es@python.org
    \end{itemize}
  \end{frame}

  \begin{frame}{Dudas}
    \begin{center}
      \dots
    \end{center}
  \end{frame}

\end{document}
